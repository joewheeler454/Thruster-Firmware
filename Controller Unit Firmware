#include <WiFi.h>
#include <esp_now.h>
#include <SPI.h>

// Configure Mac Address (Placeholder)
uint8_t THRUSTER_MAC_ADDR[] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}; 

// Pin Assignments
const int ENC_CS_PIN = 5;   // Chip Select for encoder
const int ENC_SCK_PIN = 18;  // SPI Clock 
const int ENC_MISO_PIN = 19; // SPI MISO

const int THRUST_SWITCH_PIN = 25;
const int LED_R_PIN = 26;
const int LED_G_PIN = 27;
const int LED_B_PIN = 14;

// Encoder & Angle Settings
const int ENCODER_RESOLUTION = 1024; // 10-bit encoder
const float GEAR_RATIO = 4.8; 
const float TARGET_DEGREES_PER_COUNT = (360.0 * GEAR_RATIO) / ENCODER_RESOLUTION; // Target angle change per encoder count = 1728 / 1024 = 1.6875

// Communication Settings
const unsigned long PING_INTERVAL_MS = 200; // Send data more frequently for responsiveness
const unsigned long CONNECTION_TIMEOUT_MS = 2000; // Time before considering disconnected

// SPI Settings for Encoder (Adjust based on your encoder datasheet)
SPISettings encoderSPISettings(1000000, MSBFIRST, SPI_MODE0); // 1 MHz, MSB first, Mode 0 (typical)

// --- Global Variables ---
SPIClass spi = SPIClass(VSPI); // Use VSPI peripheral (HSPI is other option)

// Data structure to send
typedef struct struct_message_send {
    float target_angle_degrees; // Cumulative target angle
    bool thrust_enabled_request;
} struct_message_send;

// Data structure to receive
typedef struct struct_message_receive {
    bool thrust_active_feedback;
    bool low_battery_feedback;
} struct_message_receive;

struct_message_send controllerData;
struct_message_receive thrusterFeedback;

// State Variables
volatile bool thrustSwitchState = false;
volatile bool thrusterActiveFeedback = false;
volatile bool lowBatteryFeedback = false;
volatile bool peerConnected = false;
volatile unsigned long lastReceiveTime = 0;
unsigned long lastSendTime = 0;
int lastRawEncoderValue = -1; // Store last reading to detect changes

// LED States
enum LedState {
    OFF,
    GREEN,
    SOLID_RED,
    FLASHING_RED
};
LedState currentLedState = OFF;
unsigned long lastLedFlashTime = 0;
bool ledFlashOn = false;
const int LED_FLASH_INTERVAL_MS = 250; // Flashing speed

// --- ESP-NOW Callbacks --- (Identical to previous version)

// Callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
    // Optional: Add debug printing
    // Serial.print("Last Packet Send Status: ");
    // Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}

// Callback when data is received
void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {
  if (len == sizeof(thrusterFeedback)) {
    memcpy(&thrusterFeedback, incomingData, sizeof(thrusterFeedback));
    // Update volatile state variables safely
    noInterrupts(); // Prevent race conditions with main loop access
    thrusterActiveFeedback = thrusterFeedback.thrust_active_feedback;
    lowBatteryFeedback = thrusterFeedback.low_battery_feedback;
    lastReceiveTime = millis();
    peerConnected = true; 
    interrupts();
    // Serial.print("Received - Thrust Active: "); Serial.print(thrusterActiveFeedback);
    // Serial.print(", Low Battery: "); Serial.println(lowBatteryFeedback);
  } else {
    Serial.println("Received data of incorrect size.");
  }
}

// --- LED Control --- (Identical to previous version)

// Assumes Common Anode RGB LED (HIGH = OFF, LOW = ON)
void setLedColor(int r, int g, int b) {
    digitalWrite(LED_R_PIN, r);
    digitalWrite(LED_G_PIN, g);
    digitalWrite(LED_B_PIN, b);
}

void updateLed() {
    LedState targetLedState = OFF;

    // Determine target state based on priority: Disconnected > Low Battery > Thruster ON > Off
    if (!peerConnected) {
        targetLedState = FLASHING_RED;
    } else if (lowBatteryFeedback) {
        targetLedState = SOLID_RED;
    } else if (thrusterActiveFeedback) {
        targetLedState = GREEN;
    } else {
        targetLedState = OFF;
    }

    // Apply state
    if (targetLedState != currentLedState || targetLedState == FLASHING_RED) {
        currentLedState = targetLedState;
        
        switch (currentLedState) {
            case OFF:
                setLedColor(HIGH, HIGH, HIGH); // All off
                break;
            case GREEN:
                setLedColor(HIGH, LOW, HIGH); // Green on
                break;
            case SOLID_RED:
                setLedColor(LOW, HIGH, HIGH); // Red on
                break;
            case FLASHING_RED:
                // Handle flashing in the main loop
                break; 
        }
    }

    // Handle flashing state separately
    if (currentLedState == FLASHING_RED) {
        unsigned long now = millis();
        if (now - lastLedFlashTime > LED_FLASH_INTERVAL_MS) {
            lastLedFlashTime = now;
            ledFlashOn = !ledFlashOn;
            if (ledFlashOn) {
                setLedColor(LOW, HIGH, HIGH); // Red on
            } else {
                setLedColor(HIGH, HIGH, HIGH); // All off
            }
        }
    }
}

// --- Serial Encoder Reading ---
// IMPORTANT: This is a *placeholder* function. Adapt to your encoder's specific SPI protocol.
// Assumes a simple 16-bit read where the lower 10 bits are the position data.
int readSerialEncoder() {
    uint16_t rawData = 0;
    
    spi.beginTransaction(encoderSPISettings);
    digitalWrite(ENC_CS_PIN, LOW); // Select encoder chip
    
    // Clock out 16 bits (adjust number of bytes/bits as needed)
    // Some encoders might require a command byte first.
    rawData = spi.transfer16(0xFFFF); // Send dummy data to receive
    
    digitalWrite(ENC_CS_PIN, HIGH); // Deselect encoder chip
    spi.endTransaction();

    // Assuming the 10-bit data is in the lower bits (adjust masking/shifting if needed)
    int position = rawData & 0x03FF; // Mask for lower 10 bits (0 to 1023)

    // Optional: Add error checking bits if your encoder provides them

    return position;
}


// --- Setup ---
void setup() {
    Serial.begin(115200);
    Serial.println("ESP32 Thruster Controller Starting (v2)...");

    // Initialize SPI for Encoder
    pinMode(ENC_CS_PIN, OUTPUT);
    digitalWrite(ENC_CS_PIN, HIGH); // Deselect initially
    // Initialize VSPI with custom pins
    spi.begin(ENC_SCK_PIN, ENC_MISO_PIN, -1, ENC_CS_PIN); // SCK, MISO, MOSI (-1 if unused), CS (ignored if controlled manually)
    Serial.println("SPI Initialized for Encoder.");

    // Initialize Switch Pin
    pinMode(THRUST_SWITCH_PIN, INPUT_PULLUP); // Use internal pull-up resistor
    Serial.println("Switch Pin Initialized.");

    // Initialize LED Pins
    pinMode(LED_R_PIN, OUTPUT);
    pinMode(LED_G_PIN, OUTPUT);
    pinMode(LED_B_PIN, OUTPUT);
    setLedColor(HIGH, HIGH, HIGH); // Start with LED off
    Serial.println("LED Pins Initialized.");

    // Initialize WiFi and ESP-NOW
    WiFi.mode(WIFI_STA); // Station mode is needed for ESP-NOW
    Serial.print("Controller MAC Address: ");
    Serial.println(WiFi.macAddress());

    if (esp_now_init() != ESP_OK) {
        Serial.println("Error initializing ESP-NOW");
        return;
    }
    Serial.println("ESP-NOW Initialized.");

    // Register callbacks
    esp_now_register_send_cb(OnDataSent);
    esp_now_register_recv_cb(OnDataRecv);

    // Register peer
    esp_now_peer_info_t peerInfo;
    memset(&peerInfo, 0, sizeof(peerInfo)); // Zero out the structure
    memcpy(peerInfo.peer_addr, THRUSTER_MAC_ADDR, 6);
    peerInfo.channel = 0;  // Use default channel 0
    peerInfo.encrypt = false; // No encryption for simplicity
    
    if (esp_now_add_peer(&peerInfo) != ESP_OK){
        Serial.println("Failed to add peer");
        return;
    }
    Serial.println("Thruster Peer Added.");

    lastReceiveTime = millis(); // Initialize to prevent immediate disconnect state
    
    // Initial read of encoder to set starting angle
    int initialEncoderValue = readSerialEncoder();
    controllerData.target_angle_degrees = (float)initialEncoderValue * TARGET_DEGREES_PER_COUNT;
    lastRawEncoderValue = initialEncoderValue;
    Serial.print("Initial Encoder Reading: "); Serial.print(initialEncoderValue);
    Serial.print(", Initial Target Angle: "); Serial.println(controllerData.target_angle_degrees);
}

// --- Main Loop ---
void loop() {
    unsigned long now = millis();
    bool sendUpdate = false;

    // --- Read Inputs ---
    int currentEncoderValue = readSerialEncoder();
    bool currentSwitchState = (digitalRead(THRUST_SWITCH_PIN) == LOW); // LOW means switch is ON/active

    // --- Calculate Target Angle ---
    // Update only if encoder value has changed
    if (currentEncoderValue != lastRawEncoderValue) {
         controllerData.target_angle_degrees = (float)currentEncoderValue * TARGET_DEGREES_PER_COUNT;
         lastRawEncoderValue = currentEncoderValue;
         sendUpdate = true; // Need to send the new angle
         // Serial.print("Encoder: "); Serial.print(currentEncoderValue);
         // Serial.print(", Target Angle: "); Serial.println(controllerData.target_angle_degrees);
    }
    
    // Update only if switch state has changed
    if (currentSwitchState != controllerData.thrust_enabled_request) {
        controllerData.thrust_enabled_request = currentSwitchState;
        sendUpdate = true; // Need to send the new switch state
        // Serial.print("Switch State Changed: "); Serial.println(controllerData.thrust_enabled_request);
    }


    // --- Check Connection Status ---
    // Safely read volatile variable
    noInterrupts();
    unsigned long lastRx = lastReceiveTime;
    interrupts();

    if (now - lastRx > CONNECTION_TIMEOUT_MS) {
        if (peerConnected) {
            Serial.println("Peer disconnected.");
            peerConnected = false;
            // Reset feedback states when disconnected
            thrusterActiveFeedback = false; 
            lowBatteryFeedback = false; 
        }
    } else {
        if (!peerConnected) {
             Serial.println("Peer connected.");
             peerConnected = true; // Connection re-established
        }
    }


    // --- Send Data Periodically or on Change ---
    // Send immediately if inputs changed, otherwise send periodically to maintain connection status
    if (sendUpdate || (now - lastSendTime > PING_INTERVAL_MS)) {
        lastSendTime = now;
        esp_err_t result = esp_now_send(THRUSTER_MAC_ADDR, (uint8_t *) &controllerData, sizeof(controllerData));
        
        // Optional: Check send result
        // if (result != ESP_OK) {
        //     Serial.println("Error sending data");
        // }
    }

    // --- Update LED Status ---
    updateLed();

    // Small delay to prevent busy-waiting, adjust as needed
    delay(5); // Reduce delay slightly for faster response
}

